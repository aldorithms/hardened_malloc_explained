# hardened_malloc explained

GrapheneOS's hardened_malloc provides enhanced memory-based security by implementing additional checks, monitoring, and defenses to detect and prevent common memory-based security vulnerabilities such as buffer overflows, use-after-free errors, and heap-based buffer overflows. 

The general purpose of a memory allocator is to allocate memory blocks on the computer’s RAM to processes in userspace. Hardened_malloc concurrently performs regular checks on the allocated memory blocks for any modifications or inconsistencies. If it detects any issues, the process will be immediately terminated to prevent further damage. Additionally, hardened_malloc randomizes the layout of allocated memory blocks in a process known as ASLR (Address Space Layout Randomization), making it harder for malware to find and corrupt the memory locations of mission critical data.
	
One vital memory location frequently targeted by attackers is the call stack, a memory region used by a program to store information about function calls and their return addresses. By overwriting this information, an attacker can force other processes to execute its own code. This is potentially catastrophic depending on the level of privilege that the victim process has. If the victim has administrator or root privileges, this could potentially lead to a complete takeover of the operating system. If the attacker manages to overwrite the program from the disk, this could allow the malware to persist on the device even after reboot. For this reason, the call stack needs to be protected.
	
One technique used is stack-smashing protection, designed to prevent attackers from exploiting buffer overflow vulnerabilities. Randomly generated values called canaries are inserted at the beginning and end of each allocated block of memory. They are called canaries because coal miners would use live canaries to detect gas leaks. When the bird stopped singing or died, it was a sign that dangerous levels of gas were present, and the miners would evacuate the mine. Similarly, when malicious software writes further than its own buffers, the canary will be overwritten, meaning that a buffer overflow has occurred. Hardened_malloc will immediately detect the error and throw a segmentation fault. This will terminate the program, preventing it from executing a malicious payload.

In addition to canaries, which are located inside memory blocks, extra pages of memory called guard pages, are placed before and after each block of allocated memory. The memory allocator marks these as inaccessible. Naturally, there is no reason for software other than hardened_malloc to access the guard page, so any attempt to do so will trigger a segmentation fault. This helps prevent buffer overflow attacks that attempt to overwrite memory outside the bounds of the allocated buffer.

Hardened_malloc is also focused on reducing the risk of memory leaks through the use of reference counting, which keeps track of how many pointers are referencing a particular memory block. This is very similar to how traditional garbage collectors work. When a pointer is no longer needed, the reference count is decremented. Once the reference counter reaches zero, the memory is freed. This helps prevent memory leaks that can occur when a program fails to free memory it no longer needs.

A dangerous side-effect of garbage collection is known as fragmentation. When heap memory is freed, it often leaves empty spaces in between the process’s main stack and the remaining heap allocated data, meaning the memory has been fragmented. When the kernel attempts to allocate a new process to userspace, and the process is bigger in size than the data that was previously freed, it won't be able to fit inside the free memory blocks. This can lead to catastrophic out-of-memory errors long before the operating system is actually out of memory. To prevent this, hardened_malloc has a few techniques to be more memory efficient.

Large memory blocks from the operating system are allocated and divided into smaller chunks for use by the process. This helps by minimizing the number of times the program needs to request memory from the operating system. 

When a memory block is freed, it is added to a free chunk list. If there are adjacent free chunks, they are merged to create a larger free block, creating larger contiguous free memory blocks, which are split into smaller ones when necessary. When a process requests memory, hardened_malloc searches the free chunk list for the smallest free chunk that can accommodate the request. If the free chunk is still too large, it is split into two smaller chunks, one of which is used for the allocation, and the other is added to the free chunk list creating smaller free memory blocks that can be used for smaller allocations. If a program frees a memory block and then requests memory of the same size, the same block will be reused, reducing the number of free chunks that need to be managed.
